{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["/// <reference path=\"../global.d.ts\" />\nimport { Point } from '@pixi/core';\nimport './pointExtras';\nimport './rectangleExtras';\n\nimport type { IPointData } from '@pixi/core';\n\n/**\n * The idea of a relative epsilon comparison is to find the difference between the two numbers,\n * and see if it is less than `Math.EPSILON`.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param {number} a - First floating number to compare.\n * @param {number} b - Second floating number to compare.\n * @returns {boolean} Returns `true` if the difference between the values is less than `Math.EPSILON`; otherwise `false`.\n */\nexport function floatEqual(a: number, b: number): boolean;\n/**\n * The idea of a relative epsilon comparison is to find the difference between the two numbers,\n * and see if it is less than a given epsilon.\n * A good epsilon would be the N% of the largest of the two values or `Math.EPSILON`.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param {number} a - First floating number to compare.\n * @param {number} b - Second floating number to compare.\n * @param {number} epsilon - The epsilon to compare to.\n * The larger the epsilon, the easier for the numbers to be considered equals.\n * @returns {boolean} Returns `true` if the difference between the values is less than the given epsilon;\n * otherwise `false`.\n */\nexport function floatEqual(a: number, b: number, epsilon: number): boolean;\nexport function floatEqual(a: number, b: number, epsilon: number = Number.EPSILON): boolean\n{\n    if (a === b)\n    {\n        return true;\n    }\n\n    const diff = Math.abs(a - b);\n\n    return diff < epsilon;\n}\n\n/**\n * Generic line or segment intersection.\n * A line can intersect outside the two points defining it, the segment can't.\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param isLine - Set to true if you want Line (unbounded) intersection.\n * @param {IPointData} [outPoint] - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the lines/segments intersect or a `NaN` Point.\n */\nfunction genericLineIntersection<T extends IPointData>(\n    aStart: IPointData,\n    aEnd: IPointData,\n    bStart: IPointData,\n    bEnd: IPointData,\n    isLine: boolean,\n    outPoint?: T): T\n{\n    if (!outPoint)\n    {\n        outPoint = new Point() as IPointData as T;\n    }\n\n    const dxa = aEnd.x - aStart.x;\n    const dya = aEnd.y - aStart.y;\n    const dxb = bEnd.x - bStart.x;\n    const dyb = bEnd.y - bStart.y;\n\n    // In order to find the position of the intersection in respect to the line segments, we can define lines\n    // in terms of first degree Bézier parameters, and find the two parameters `ua` and `ub` for the two lines to touch.\n    // both `ua` and `ub` formula share the same denominator so it is only calculated once.\n\n    const denominator = ((dyb * dxa) - (dxb * dya));\n\n    // If lines are parallel or overlapping, the intersection can be nowhere or everywhere... NaN.\n    if (floatEqual(denominator, 0))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    // ua is the factor of line a where the intersection occurs. ub is the factor of line b where the intersection occurs.\n    const ua = ((dxb * (aStart.y - bStart.y)) - (dyb * (aStart.x - bStart.x))) / denominator;\n    const ub = ((dxa * (aStart.y - bStart.y)) - (dya * (aStart.x - bStart.x))) / denominator;\n\n    // Line intersection extends beyond the bounds of the segment.\n    // The intersection is inside the segments if 0.0 ≤ ua ≤ 1.0 and 0.0 ≤ ub ≤ 1.0\n    if (!isLine && (ua < 0 || ua > 1 || ub < 0 || ub > 1))\n    {\n        outPoint.x = NaN;\n        outPoint.y = NaN;\n\n        return outPoint;\n    }\n\n    outPoint.x = aStart.x + (ua * dxa);\n    outPoint.y = bStart.y + (ub * dyb);\n\n    return outPoint;\n}\n\n/**\n * Computes the point where non-coincident and non-parallel Lines intersect.\n * Coincident or parallel lines return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point may land outside the extents of the lines.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @returns {IPointData} The point where the lines intersect.\n */\nexport function lineIntersection(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData): Point;\n/**\n * Computes the point where non-coincident and non-parallel Lines intersect.\n * Coincident or parallel lines return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point may land outside the extents of the lines.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param aStart - First point of the first line.\n * @param aEnd - Second point of the first line.\n * @param bStart - First point of the second line.\n * @param bEnd - Second point of the second line.\n * @param {IPointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the lines intersect or a `NaN` Point.\n */\nexport function lineIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint: T): T;\nexport function lineIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, true, outPoint);\n}\n\n/**\n * Computes the point where non-coincident and non-parallel segments intersect.\n * Coincident, parallel or non-intersecting segments return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point must land inside the extents of the segments or return a `NaN` Point.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @param aStart - Starting point of the first segment.\n * @param aEnd - Ending point of the first segment.\n * @param bStart - Starting point of the second segment.\n * @param bEnd - Ending point of the second segment.\n * @returns {IPointData} The point where the segments intersect.\n */\nexport function segmentIntersection(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData): Point;\n/**\n * Computes the point where non-coincident and non-parallel segments intersect.\n * Coincident, parallel or non-intersecting segments return a `NaN` point `{x: NaN, y: NaN}`.\n * The intersection point must land inside the extents of the segments or return a `NaN` Point.\n *\n * _Note: Only available with **@pixi/math-extras**._\n * @memberof PIXI\n * @param aStart - Starting point of the first segment.\n * @param aEnd - Ending point of the first segment.\n * @param bStart - Starting point of the second segment.\n * @param bEnd - Ending point of the second segment.\n * @param {IPointData} outPoint - A Point-like object in which to store the value,\n * optional (otherwise will create a new Point).\n * @returns {IPointData} The point where the segments intersect or a `NaN` Point.\n */\nexport function segmentIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint: T): T;\nexport function segmentIntersection\n<T extends IPointData>(aStart: IPointData, aEnd: IPointData, bStart: IPointData, bEnd: IPointData, outPoint?: T): T\n{\n    return genericLineIntersection(aStart, aEnd, bStart, bEnd, false, outPoint);\n}\n"],"names":[],"mappings":";;;;AAgCO,SAAA,UAAA,CAAoB,CAAW,EAAA,CAAA,EAAW,OAAkB,GAAA,MAAA,CAAO,OAC1E,EAAA;AACI,EAAA,IAAI,MAAM,CACV,EAAA;AACI,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAEA,EAAA,MAAM,IAAO,GAAA,IAAA,CAAK,GAAI,CAAA,CAAA,GAAI,CAAC,CAAA,CAAA;AAE3B,EAAA,OAAO,IAAO,GAAA,OAAA,CAAA;AAClB,CAAA;AAcA,SAAA,uBAAA,CACI,MACA,EAAA,IAAA,EACA,MACA,EAAA,IAAA,EACA,QACA,QACJ,EAAA;AACI,EAAA,IAAI,CAAC,QACL,EAAA;AACI,IAAA,QAAA,GAAW,IAAI,KAAM,EAAA,CAAA;AAAA,GACzB;AAEA,EAAM,MAAA,GAAA,GAAM,IAAK,CAAA,CAAA,GAAI,MAAO,CAAA,CAAA,CAAA;AAC5B,EAAM,MAAA,GAAA,GAAM,IAAK,CAAA,CAAA,GAAI,MAAO,CAAA,CAAA,CAAA;AAC5B,EAAM,MAAA,GAAA,GAAM,IAAK,CAAA,CAAA,GAAI,MAAO,CAAA,CAAA,CAAA;AAC5B,EAAM,MAAA,GAAA,GAAM,IAAK,CAAA,CAAA,GAAI,MAAO,CAAA,CAAA,CAAA;AAM5B,EAAM,MAAA,WAAA,GAAgB,GAAM,GAAA,GAAA,GAAQ,GAAM,GAAA,GAAA,CAAA;AAG1C,EAAI,IAAA,UAAA,CAAW,WAAa,EAAA,CAAC,CAC7B,EAAA;AACI,IAAA,QAAA,CAAS,CAAI,GAAA,GAAA,CAAA;AACb,IAAA,QAAA,CAAS,CAAI,GAAA,GAAA,CAAA;AAEb,IAAO,OAAA,QAAA,CAAA;AAAA,GACX;AAGA,EAAM,MAAA,EAAA,GAAO,CAAO,GAAA,IAAA,MAAA,CAAO,CAAI,GAAA,MAAA,CAAO,KAAO,GAAO,IAAA,MAAA,CAAO,CAAI,GAAA,MAAA,CAAO,CAAO,CAAA,IAAA,WAAA,CAAA;AAC7E,EAAM,MAAA,EAAA,GAAO,CAAO,GAAA,IAAA,MAAA,CAAO,CAAI,GAAA,MAAA,CAAO,KAAO,GAAO,IAAA,MAAA,CAAO,CAAI,GAAA,MAAA,CAAO,CAAO,CAAA,IAAA,WAAA,CAAA;AAI7E,EAAI,IAAA,CAAC,WAAgB,EAAA,GAAA,CAAA,IAAK,KAAK,CAAK,IAAA,EAAA,GAAK,CAAK,IAAA,EAAA,GAAK,CACnD,CAAA,EAAA;AACI,IAAA,QAAA,CAAS,CAAI,GAAA,GAAA,CAAA;AACb,IAAA,QAAA,CAAS,CAAI,GAAA,GAAA,CAAA;AAEb,IAAO,OAAA,QAAA,CAAA;AAAA,GACX;AAEA,EAAS,QAAA,CAAA,CAAA,GAAI,MAAO,CAAA,CAAA,GAAK,EAAK,GAAA,GAAA,CAAA;AAC9B,EAAS,QAAA,CAAA,CAAA,GAAI,MAAO,CAAA,CAAA,GAAK,EAAK,GAAA,GAAA,CAAA;AAE9B,EAAO,OAAA,QAAA,CAAA;AACX,CAAA;AAgCO,SAAA,gBAAA,CACgB,MAAoB,EAAA,IAAA,EAAkB,MAAoB,EAAA,IAAA,EAAkB,QACnG,EAAA;AACI,EAAA,OAAO,wBAAwB,MAAQ,EAAA,IAAA,EAAM,MAAQ,EAAA,IAAA,EAAM,MAAM,QAAQ,CAAA,CAAA;AAC7E,CAAA;AAgCO,SAAA,mBAAA,CACgB,MAAoB,EAAA,IAAA,EAAkB,MAAoB,EAAA,IAAA,EAAkB,QACnG,EAAA;AACI,EAAA,OAAO,wBAAwB,MAAQ,EAAA,IAAA,EAAM,MAAQ,EAAA,IAAA,EAAM,OAAO,QAAQ,CAAA,CAAA;AAC9E;;;;"}